\documentclass{article}

% *** CITATION PACKAGES *** 

\usepackage{cite}

% *** GRAPHICS RELATED PACKAGES *** 

\usepackage[pdftex]{graphicx}
\usepackage{tikz}

% *** MATH PACKAGES ***

\usepackage{amsmath} 
\usepackage{amssymb} 
\usepackage{amsthm}
\usepackage{latexsym} 
\usepackage{amstext}
\usepackage{amsxtra} 
\usepackage{amsfonts} 
\usepackage{graphicx}


\usepackage{algorithmic}
\usepackage{algorithm}

% *** ALIGNMENT PACKAGES *** 


\usepackage{array} 
\usepackage{mdwmath}
\usepackage{mdwtab} 

\usepackage[tight,footnotesize,caption=false]{subfig}

% *** CITATION PACKAGE *** %
% ** IJRR asks for an author-date bibtex style ** %
\usepackage{harvard}


\newtheorem{theorem}{Theorem}


\begin{document}

\title{Whole-Body Manipulation Planning for Humanoid Robots}

\author{
  S\'ebastien Dalibard\and
  Antonio El Khoury\and
  Florent Lamiraux\and
  Alireza Nakhaei\and
  Michel Ta\"ix\and
  Jean-Paul Laumond
  \footnote{The authors are with CNRS ; LAAS ; 7 avenue du colonel Roche, F-31077
    Toulouse Cedex 4, France and Universit\'e de Toulouse ; UPS, INSA, INP, ISAE ;
    UT1, UTM, LAAS ; F-31077 Toulouse
    Cedex 4, France. S\'ebastien Dalibard is now with Nanyang Technological University, Singapore.}
  \footnote{
    This paper summarizes and and extends previous work that appeared in the 9th and 11th
    IEEE-RAS International Conference on Humanoid Robots, 2009 and 2011.
  }
}

\date{}

\maketitle

\begin{abstract}

\end{abstract}

\section{Introduction}

Redundancy, walk

Local planning

different levels of complexity

\subsection{Outline}
Section~\ref{sec:related} reviews the related work and states our contribution. 
Section~\ref{sec:wb} presents a constrained motion planning algorithm, and its
use on a humanoid robot manipulation problem. Section~\ref{sec:wb-step} generalizes
the previous algorithm to problems that require locomotion. The generalization is
well-grounded, and
based on a controllability property of legged robots demonstrated in the paper. 
Section~\ref{sec:exp} presents some experimental results, and 
Section~\ref{sec:limits} discusses the limitations and potential future work of our
method.


\section{Related Work and Contribution}
\label{sec:related}


This work is based on several fields of humanoid robotics
research: prioritized inverse kinematics, randomized  whole-body  motion
planning and walk pattern generators based on the Zero-Momentum
Point (ZMP) formalism. This section summarizes the related work for each of them.

\subsection{Prioritized Inverse Kinematics}

The problem of inverse kinematics for a humanoid robot, or any articulated
structure, is to compute a joint motion to achieve an end-effector pose. As the
robots we deal with are redundant, it is natural to take advantage of
this redundancy by specifying multiple tasks, potentially with
different priorities. This problem has been widely studied in robotics
planning and control literature, and many jacobian-based solutions have been
proposed, among which 
\cite{nakamura1986iks}, \cite{siciliano1991gfm},
\cite{baerlocher1998tpf} and \cite{khatib2004wbd}.
Obstacle avoidance can be taken into account with similar methods. To
do so, one has to include the obstacles as other task constraints to
be satisfied. A recent  contribution on this subject is \cite{kanehiro2008lca}.
These methods are prone to fall into local minima, global motion 
planning is needed to overcome this limitation.

\subsection{Whole-Body Motion Planning}

When  planning a  whole-body motion  for a  humanoid robot, one difficult
challenge is to cope with  the curse of dimensionality. The complexity
of   motion  planning  is   exponential  in   the  dimension   of  the
configuration  space ($\mathcal{C}$)  to explore.  When  dealing with
high-dimensional configuration  spaces, it is  typically impossible to
explicitly represent  them, leading to the use  of randomized sampling
techniques  to solve  global planning  problems. In  the  past fifteen
years,  \textit{Probabilistic Roadmaps} \cite{kavraki1996prp} and  
\textit{Rapidly exploring Random  Trees} (RRT) 
\cite{kuffner00rrtconnect}  have been  developed and  used to  solve many
high-dimensional   planning  problems.
When  using  sampling  techniques  on  a humanoid  robot,  another difficulty
difficulty  is to  take into  account stability  constraints,  i.e. to
generate  random  configurations   on  zero  volume  submanifolds  of
$\mathcal{C}$. This problem has been investigated with success during
the last few years, \cite{Berenson15032011} presents a exhaustive survey
of jacobian-based methods. Other recent contributions \cite{porta2012randomized}
present sophisticated constrained planning techniques based on higher-dimensional
continuation. Section \ref{sec:wb} presents a simple adaptation
of the RRT algorithm to constrained motion planning, that was first
introduced in \cite{dalibard09}.

\subsection{Walk Pattern Generation}

Another  field of  humanoid  robotics research  is  the generation  of
dynamically stable  walk patterns. Since  the introduction of  the ZMP
formalism  \cite{vukobratovic1969contribution},  several  methods  have  been  proposed  to
generate  walking  motions efficiently.   One  way  to  deal with  the
complexity  of a  humanoid  robotics  kinematic tree  is  to use  the
so-called "cart-table" simplified model \cite{kajita2003biped}. Based on such a
model,  planning a trajectory  for the  ZMP is  reduced to  planning a
trajectory  for  the Center  of  Mass (CoM)  of  the  robot.  Given  a
trajectory  of  the CoM  and  footstep  positions, inverse  kinematics
solvers can animate  the whole set of degrees of freemdom (DoFs) of the  
robot to generate a dynamically stable walk trajectory.


\subsection{Collision-Free Walk Planning}

Collision-free  locomotion   trajectories  are  usually   obtained  by
simplifying the model of the  robot or of its environment. By reducing 
a  humanoid robot to a bounding volume, that includes its swaying motions,
one can  use a simple  planar motion planner  on this bounding  volume and
generate  a valid  locomotion  trajectory. This  strategy  is used  in
\cite{pettre20032} in a computer animation context. Variants of this method
include  dynamic path reshaping  \cite{yoshida-humanoids05}: if  collisions appear
when animating  the locomotion  trajectory, it is  locally reshaped
and re-animated.  This two-stage  strategy does not guarantee that the
locomotion trajectory can be followed or that the local reshaping will
converge.

Simplifying  the environment  consists in  considering obstacles  at a
footstep   level.   \cite{chestnutt2005footstep,kuffner2005motion}
use   an  
A$^{*}$   algorithm  to   find
collision-free   footsteps.    In   \cite{perrinbiped},   the   authors   compute
collision-free motions  for the legs by using  an RRT$^{*}$ algorithm. 

Some planning methods for free-climbing robots \cite{bretl2006motion}
can be seen as a general way 
to consider quasi-static multi-step planning. They are not directly applicable to
humanoid dynamically stable locomotion.
Other recent contributions to the field of locomotion planning  include algorithms 
considering the dynamics at the planning phase \cite{shkolnik2011bounding}. This leads to 
a growth of algorithmic complexity, particularly costly for high-dimensional
systems such as humanoid robots. In our work, we show that it is not always
necessary to take into account dynamics while planning, even though the final
output of our algorithm is a dynamically stable walk motion.



\subsection{Contribution}

The main contribution of this work is a  whole-body motion planner for humanoid robots
that computes collision-free walking trajectories, based on
exact models of both robot and environment. It is used to solve manipulation tasks
that may require walking. The first stage of our algorithm uses a
constrained sampling-based motion 
planner and  computes a collision-free path  for a statically stable robot on the
ground. Another  contribution of this  paper is the formal  proof that
this first path can always be  approximated by a dynamically balanced, collision-free
walking  trajectory in a second stage. We have implemented this well-grounded 
method and  used it on a model of  HRP-2 robot.  The results have been  
validated on a real platform.

\section{Randomized Motion Planning on Constrained Manifolds}
\label{sec:wb}

This section presents an algorithm for constrained motion planning. 
The problem solved here
differs from classic configuration approaches in two ways:
\begin{enumerate}
\item the set of valid configurations is defined implicitly, as the ones satisfying a given 
  set of inverse kinematic tasks;
\item the goal is also defined implicitely, by another set of inverse kinematic tasks.
\end{enumerate}
In this presentation, we use a prioritized inverse kinematic solver, or local planner,
 as a black box. We will not describe the details of its implementation. They are presented in 
\cite{yoshida2006tds}, and are out of scope of the present work.


During global planning, we will consider several types of
tasks and constraints for various reasons:
\begin{itemize}
\item  Static stability: the center of mass of the robot stays at
  the vertical of the support polygon center, the two feet have fixed position and
  orientation.
\item End-effector position and orientation: the goals of some problems presented
  in the experimental section of this paper are defined as robot hand configuration,
  or gaze direction.
\item Configuration task: our adaptation of randomized motion planning algorithms 
  uses tasks defined as the distance towards a given configuration in $\mathcal{C}$. 
  This will be detailed in the following of the section.
\end{itemize}


The architecture of the constrained planning algorithm presented here follows
the one of randomized tree expansion strategies, introduced in both \cite{HsuLat99c} and
\cite{kuffner00rrtconnect}. Next subsection will recall the structure of the RRT algorithm,
a popular randomized motion planning algorithm.


\subsection{Rapidly exploring Random Trees (RRT)}

The classic RRT algorithm, as presented in  \cite{kuffner00rrtconnect}, grows 
a random tree inside a robot 
collision-free configuration space 
$\mathcal{C}_{free}$. Each iteration of the algorithm attempts to extend the tree
by adding new vertices in the direction of a randomly-selected configuration
$q_{rand}$. Algorithm~\ref{algRRT} shows the pseudo-code of the RRT algorithm.
It takes as input an initial configuration $q_0$ and grows a tree  $\mathcal{T}$ rooted 
in $q_0$. 

\begin{algorithm}
\caption{RRT($q_0$)}
\label{algRRT}
\begin{algorithmic}
\STATE $\mathcal{T}.$Init$(q_0)$
\FOR{$i$ = 1 to $K$}
\STATE $q_{rand} \leftarrow $ Rand$(\mathcal{C})$
\STATE $q_{near} \leftarrow $ Nearest$(q_{rand},\mathcal{T})$
\STATE Extend$(q_{near},q_{rand})$
\ENDFOR

\end{algorithmic}
\end{algorithm}

One way to make the RRT algorithm more efficient is to grow trees from both the initial
and  goal configurations. This was first proposed in 
\cite{kuffner00rrtconnect}. Our formulation of manipulation planning does
not include an explicit goal configuration, so it is not possible to directly grow
a tree from the goal. To make use of the idea of growing multiple trees, we first
randomly sample the goal submanifold and generate several goal configurations. Then, 
we grow random
trees from the initial configuration and the random goal configurations. The idea of
generating several goals for manipulation planning was proposed in \cite{diankov2008bpc}.

Section~\ref{sec:goal-sampling}  describes the goal manifold sampling, and 
Section~\ref{sec:extension} the adaptation or RRTs random extensions to constrained planning.

\subsection{Goal Manifold Sampling}
\label{sec:goal-sampling}

The way we generate a goal configuration is the following:
\begin{enumerate}
\item Shoot a random configuration in $\mathcal{C}$ with uniform distribution.
\item Call the local planner on this configuration, with the static
  stability constraints and the goal task.
\item Check that all of those tasks are achieved.
\item Check for collisions.
\end{enumerate}

Fig.~\ref{fig:goal} shows different random configurations respecting stability 
constraints and solving a reaching task for an animated character. 

\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{pics/goal.png}

\caption{Random goal configurations solving a reaching task. All the
  configurations are stable and collision-free, and the right hand of the character
  reaches the purple box.}
\label{fig:goal}
\end{figure}



\subsection{Random Extensions on a Constrained Manifold}
\label{sec:extension}



Fig.~\ref{fig:rrt-extend} shows an extension of the classic 
RRT algorithm, from a configuration already in the tree $q_{near}$ towards a random
configuration $q_{rand}$.

\begin{figure}[h]
  \centering

  \begin{tikzpicture}[x=0.5cm,y=0.5cm]

    \node [draw,circle,inner sep=2pt] (0) at (0,0) {};
    \node [draw,circle,inner sep=2pt] (1) at (1,1) {};
    \node [draw,circle,inner sep=2pt] (2) at (2.4,1) {};
    \node [draw,circle,inner sep=2pt,fill=gray] (qn) at (3.4,2) {};
    \node [above left] at (qn) {$q_{near}$};
    \node (t) at (1.5,-0.5) {$\mathcal{T}$};
    \draw (0) -- (1) -- (2) -- (qn) ; 

    \node [draw,circle,inner sep=2pt] (qn1) at (4.8,2) {};
    \node [draw,circle,inner sep=2pt] (qn2) at (6.2,2) {};
    \node [draw,circle,inner sep=2pt] (qn3) at (7.6,2) {};

    \draw (qn) -- (qn1) -- (qn2) -- (qn3) ;


    \path [<->,thick,red] (3.4,1.5) edge  node [below,black]
          {$\varepsilon$}  (4.8,1.5) ;
          \path [<->,thick,red] (4.8,1.5) edge  node [below,black]
                {$\varepsilon$}  (6.2,1.5) ;
                \path [<->,thick,red] (6.2,1.5) edge  node [below,black]
                      {$\varepsilon$} (7.6,1.5) ;

                      \node [rectangle] (newconf) at (6.2,3.5) {\begin{small}new configurations\end{small}};

                      \draw [->,blue] (newconf) -- (qn1.north) ;
                      \draw [->,blue] (newconf) -- (qn2.north) ;
                      \draw [->,blue] (newconf) -- (qn3.north) ;

                      \node [draw,circle,inner sep=2pt] (qrand) at (13,2) {};
                      \node [below right] at (qrand) {$q_{rand}$};

                      \draw [dashed,thin] (qn3) -- (qrand) ;

  \end{tikzpicture}

  \caption{One step of extension of the RRT algorithm} 
  \label{fig:rrt-extend}
\end{figure}

The equivalent random  extension on a constrained manifold $\mathcal{M}$
starts from a valid configuration $q_{near} \in \mathcal{M}$, and extends the tree
towards a random configuration $q_{rand}$, while keeping the constraints
satisfied. To do so, we add a task to the local planner, whose value
is the distance to  $q_{rand}$ in $\mathcal{C}$. Algorithm~\ref{alg:constrained}
shows the pseudo-code of a constrained random extension from  $q_{near}$ towards
$q_{rand}$ while satisfying the constraints defining $\mathcal{M}$: $Constraints$.
The configuration space task used to explore $\mathcal{C}$ is 
noted $ConfigurationTask$.   This
task is added with the lowest priority. Each new configuration $q_{new}$ generated by the
local planner  is 
checked for constraint satisfaction and collision 
avoidance. If the new configuration is valid, each new edge is checked for collision
avoidance, as in a classic RRT algorithm.

\begin{algorithm}[h]
  \caption{Constrained-Extend($\mathcal{T},q_{near},q_{rand},Constraints$)}
  \label{alg:constrained}
  \begin{algorithmic}
    \STATE $Tasks.$Initialize$(Constraints)$
    \STATE $ConfigurationTask$.SetTarget($q_{rand}$)
    \STATE $Tasks.$Add$(ConfigurationTask)$
    \STATE $q_{current} \leftarrow q_{near}$
    \STATE $State \leftarrow$ Progressing
    \WHILE{$State =  $ Progressing}
    \STATE $q_{new} \leftarrow $ LocalPlannerPerformOneStep($Tasks,q_{current}$)
    \IF{$q_{new} \neq q_{current}$ \\ 
      and CollisionCheck($q_{new}$) = OK\\ 
      and CollisionCheckEdge($q_{current},q_{new}$) = OK \\
      and ConstraintsCheck($q_{new},Constraints$) = OK }
    \STATE $\mathcal{T}$.AddNode($q_{new}$)
    \STATE $\mathcal{T}$.AddEdge($q_{current},q_{new}$)
    \STATE $q_{current} \leftarrow q_{new}$
    \IF{$q_{target} = q_{rand}$}
    \STATE $State \leftarrow$ Reached
    \ENDIF
    \ELSE 
    \STATE $State \leftarrow$ Trapped
    \ENDIF
    \ENDWHILE

  \end{algorithmic}
\end{algorithm}



Fig. \ref{fig:gikrrt} shows one step of constrained
extension, and the prioritized stack of tasks and constraints solved by the local planner.



\begin{figure}[h]
\centering
  \begin{tikzpicture}[x=0.61cm,y=0.61cm]
    \definecolor{dg}{rgb}{0,0.3,0}
     \draw [dashed,color=dg,thick,text width=2cm] (1,1)
      arc(139:90:10.61) node [above right] {\small{Constrained manifold $\mathcal{M}$}} ; 
      \node [draw,circle,inner sep=2pt,fill=gray] (qnear) at (2,2) {};
      \node [left] (qn0) at (qnear) {$q_{near}$} ;
      \node [draw,circle,inner sep=2pt] (q1) at (3,3) {};
      \node [draw,circle,inner sep=2pt] (q2) at (4,4) {};
      \node [draw,circle,inner sep=2pt] (q3) at (5,5) {};
      \node [draw,circle,inner sep=2pt] (qrand) at (7,7) {};
      \node [below right] (qr0) at (qrand) {$q_{rand}$} ;
      \draw [dashed,thin] (qnear) -- (q1) -- (q2) -- (q3) -- (qrand) ;

    \node [draw,circle,inner sep=2pt,fill=gray] (qc1) at (3.11,2.83) {};
      \draw (qnear) -- (qc1);
      \node [draw,circle,inner sep=2pt,fill=gray] (qc2) at (4.26,3.49) {};
      \draw (qc1) -- (qc2);
     \node [draw,circle,inner sep=2pt,fill=gray] (qc3) at (5.37,3.97) {};
      \draw (qc2) -- (qc3);
      \node [rectangle] (newconf) at (6,2) {\small{new configurations}}; 
      \draw [->,blue] (newconf) -- (qc1) ;
      \draw [->,blue] (newconf) -- (qc2) ;
      \draw [->,blue] (newconf) -- (qc3) ;


      \draw [color=black, thick,fill = white] (15,1) rectangle (17,2);
      \draw [color=black, thick,fill = white] (15,2) rectangle (17,3);
      \draw [color=black, thick,fill = white] (15,3) rectangle (17,5);
      \draw [color=black, thick,fill = white] (15,5) rectangle (17,6);
      \draw [color=black, thick,fill = white] (15,6) rectangle (20,7);
      \draw [color=black, thick,fill = white] (16,1) rectangle (20,6);
      \draw [thick] (16,1) -- (20,1) -- (20,6);
      \draw (16,2) -- (20,2) ;
      \node [text width = 5cm,text centered] at (17.5,6.5) {\large Stack
        of tasks};
      \begin{scriptsize}
        \node at (15.5,5.5) {1};
        \node at (15.5,4) {$\vdots$}; 
        \node at (15.5,2.5) {$n$};
        \node at (15.5,1.5) {$n$+1};

        \node [text width = 2cm,color=dg] at (18.2,4) {\small Constraints defining
          $\mathcal{M}$};
        \node [text width = 3cm,text centered] at (18,1.5)
              { Configuration task towards $q_{rand}$};    
      \end{scriptsize}


\end{tikzpicture}


\caption{One step of constrained extension, and the stack of tasks used
  to generate new configurations with a local planner starting from $q_{near}$:
  first, the constraints defining $\mathcal{M}$, and at a lower priority
  a configuration task towards $q_{rand}$.}
\label{fig:gikrrt}
\end{figure}





\subsection{Example}

An experimental study, presented in  \cite{dalibard09}, showed that
in complex environments, randomized motion planners were faster than
collision avoiding local planners. Another benefit of using global motion
planning compared to local gradient descent is the ability to avoid local 
minima. 


We present in Fig.~\ref{fig:wb-shelves} an illustration of 
the use of randomized motion planning 
on complex manipulation problems. The humanoid robot HRP-2, faces shelves. It has to: (i) grasp
a ball lying on a shelf, (ii) put it on a higher shelf, (iii) come back to a natural
rest configuration. The statically stable manifold on which the planning takes place is
defined by tasks constraining the robot feet and CoM. The goal of the first problem
is defined by a hand configuration task (position and orientation), and a gaze task
(the robot has to see the ball). The goal of the second problem is defined by a 
different hand configuration and the same gaze task,
and finally, the goal of the third problem is the rest configuration.
Extension 1 presents a video of this motion.


\begin{figure}[h]
\centering
\includegraphics[width=0.24\linewidth]{pics/wb-shelves/1.jpg}
\includegraphics[width=0.24\linewidth]{pics/wb-shelves/2.jpg}
\includegraphics[width=0.24\linewidth]{pics/wb-shelves/3.jpg}
\includegraphics[width=0.24\linewidth]{pics/wb-shelves/4.jpg}
\\
\vskip 0.08cm
\includegraphics[width=0.24\linewidth]{pics/wb-shelves/5.jpg}
\includegraphics[width=0.24\linewidth]{pics/wb-shelves/6.jpg}
\includegraphics[width=0.24\linewidth]{pics/wb-shelves/7.jpg}
\includegraphics[width=0.24\linewidth]{pics/wb-shelves/8.jpg}



\caption{HRP-2 grabs a ball on a shelf, puts it on another shelf, and comes back to 
  a rest position. Static stability constraints are respected along the path, and 
  the intermediary goals consisting in grasping and displacing the ball are defined
  implicitly as inverse kinematic tasks.}
\label{fig:wb-shelves}
\end{figure}



The motion presented in Fig.~\ref{fig:wb-shelves} looks very complicated.
The reasons are that the environment is complex and HRP-2 kinematic chain is highly constrained.
The motion has been optimized based on these constraints. Note that the
accessibility space of this robot is not wide enough to accomplish this task further 
away from the shelves, which could have ease the motion. One possibility to extend the
robot accessibility space is to automatically change the support polygon to solve the task.
This is an ongoing research field, \cite{OussamaKanoun06102010} proposes some 
local solutions. This has not been integrated in our global planning algorithm yet.



\section{From Statically Stable Paths to Dynamic Walk Trajectories}
\label{sec:wb-step}

The previous section has presented a simple algorithm that solves manipulation planning
problems on a given constrained manifold of $\mathcal{C}$. 

If we use this algorithm with static 
stability constraints without fixing globally the robot foot positions, it generates 
statically stable paths for a robot sliding on the ground. Fig~\ref{fig:sliding} shows
an example of a whole-body collision-free path for a robot passing between two chairs.
Such paths are physically unfeasible. They are, however, easier to generate than feasible
dynamic trajectories because only geometric constraints are considered at planning time.

\begin{figure}[h]
  \centering

  \includegraphics[width=0.24\linewidth]{pics/chairs/sliding-perspective-1.png}
  \includegraphics[width=0.24\linewidth]{pics/chairs/sliding-perspective-2.png}
  \includegraphics[width=0.24\linewidth]{pics/chairs/sliding-perspective-3.png}
  \includegraphics[width=0.24\linewidth]{pics/chairs/sliding-perspective-4.png}


  \caption{Collision-free  statically stable path  for a  humanoid  robot  sliding on  the
    ground.}
  \label{fig:sliding}
\end{figure}



This section presents a \textit{constructive} proof that any such statically stable, 
collision-free path for a legged robot sliding
on the ground can be approximated by a collision-free dynamic walk trajectory.
The proof is based on ideas from control theory, in particular small-space 
controllability. It also uses the fact that balanced criteria for dynamic walk are different
from the ones for static stability. An important point is that our result and method do not hold
for a biped robot that walks in a quasi-static way. 

Section~\ref{sec:ssc} recalls the definition of small-space controllability and its
use in motion planning. Section~\ref{sec:humanoid-ssc} proves that a legged robot
dynamically walking is small-space controllable, while a legged robot quasi-statically
walking is not. Section~\ref{sec:ssc-application} shows how this property is used to
approximate collision-free statically stable paths by dynamic walk trajectories.


\subsection{Small-Space Controllability}
\label{sec:ssc} 

A  robotic system  is  controllable  if  for any two  configurations
$q_1$ and $q_2$,  there exists  a
trajectory  going  from  $q_1$ to  $q_2$.  It  is  
\textit{small-space  controllable} if for  any configuration  $q$, 
for any $\epsilon >0$, there
exist $\eta >0$ such that all the configurations contained in the ball of center
$q$ and radius $\eta$ are reachable by trajectories included in the
ball of center $q$ and radius $\epsilon$.

The main  consequence of  that property  
in  motion planning  is the following theorem, that shows how planning for
dynamic systems is reduced to geometric planning
thanks to small-space controllability:

\begin{theorem}
  \label{thm:ssc}
  Any collision-free path of a small-space controllable system can be approximated
  by a sequence of both collision-free and admissible trajectories. Thus, small-space 
  controllability reduces trajectory planning problems to geometric path planning problems.
\end{theorem}

Fig. \ref{fig:stc} shows an example of collision-free 
path approximation by admissible collision-free sub-trajectories. The fact 
that this algorithm  converges is guaranteed by the small-space
controllability property.

\begin{figure}[h]
  \centering

  \begin{minipage}{3cm}
    \input{stc1.tex}
  \end{minipage}
  \begin{minipage}{4cm}
    \input{stc2.tex}
  \end{minipage}
  
  \caption{Small-space controllability in motion planning. On the left,
    the local property: any configuration $q'$ at distance less than
    $\eta$ is reachable from $q$ by an admissible trajectory included in
    a ball of size $\epsilon$. On the right, a collision-free path from
    $q_1$ to $q_2$ is approximated by collision-free and admissible
    trajectories by using the local property.
  }
  \label{fig:stc}
\end{figure}

This result has been long known and used in motion planning, in particular in planning
for non-holonomic systems. A detailed proof of it can be found in
\cite{taix-94}. We will present a sketch of the proof to give an intuition about the 
corresponding algorithm.

\begin{proof}
  Let $\mathcal{C}$ be the configuration space of a small-space controllable robot, and 
  $\mathcal{C}_{free} \subset \mathcal{C}$ the set of collision-free configurations. We
  consider in-contact configurations as colliding, so $\mathcal{C}_{free}$ is an open set.
  Let $\tau : [0,1] \rightarrow \mathcal{C}_{free}$ be a collision-free path. For every $x \in [0,1]$,
  $\tau(x) \in \mathcal{C}_{free}$, so there exists $\epsilon_x$ such that the open ball 
  $B(\tau(x),\epsilon_x)$ of center $\tau(x)$ and radius $\epsilon_x$ is included in 
  $\mathcal{C}_{free}$. The small-space controllability property states that for every $x$,
  there exist $\eta_x$ such that every configuration $q \in B(\tau(x),\eta_x)$ is reachable 
  from $\tau(x)$ by a trajectory included in $B(\tau(x),\epsilon_x)$.

  The set of open balls $\left( B(\tau(x),\eta_x) \right)_{x\in [0,1]}$ forms an open cover
  of $\tau([0,1])$ which is compact. The Heine-Borel theorem states that there exists a
  finite subcover $\left( B(\tau(x_i),\eta_{x_i}) \right)_{i\in \{ 1,\dots ,n \}}$ of $\tau([0,1])$. To this
  finite subcover corresponds a finite number of feasible trajectories, going from $\tau(0)$ to  
  $\tau(1)$, included in the union of 
  $\left( B(\tau(x_i),\epsilon_{x_i}) \right)_{i\in \{ 1,\dots ,n \}}$, and thus in 
  $\mathcal{C}_{free}$. This concludes the proof.
\end{proof}

\subsubsection{Small-Time \textit{versus} Small-Space Controllability}
In the control theory literature, the property used is usually \textit{small-time controllability}, 
which states that for  any configuration  $q$, for  any time
$T>0$, the set of configurations accessible from $q$ in time less than
$T$ forms a  neighborhood of $q$. When accelerations and velocities are bounded,
small-time controllability implies small-space controllability, which is why 
a lot of motion planning previous work only refers to the sufficient small-time controllability
property. However, the reciprocate is not necessarily true:  a system can be 
small-space controllable and
not small-time, if the trajectories generated by its controller are arbitrarily long.
The important property
in terms of motion planning application is the small-space controllability, as 
Theorem~\ref{thm:ssc} shows. In the following, we show that legged robots
are small-space controllable, but  not that they are small-time controllable.
In fact, the  control method that we present does not follow the small-time controllability
property. For the sake of clarity, we have chosen to make the distinction between these
two controllability properties.



\subsection{Walking Robot Controllability}
\label{sec:humanoid-ssc}

This section  discusses the small-space controllability of walking robots. To clarify
the presentation, we consider a simplified model of legged robot consisting of two feet
of null mass and a punctual mass free to move in three dimensions.
We do not consider 
the kinematic chains between the feet and the mass. The robot is walking on a flat terrain,
and the feet are assumed to have a positive surface. For our presentation, it is not 
necessary to consider the feet height, so the configuration space of the robot is:
\[
\mathcal{C} = SE(2) \times SE(2) \times \mathbb{R}^3
\]
It is of dimension 9.


The balanced walking conditions for a quasi-static walking robot are that the punctual
mass, or CoM, should always be over the support polygon (the convex hull of the two feet), and 
one foot can move iff the CoM is over the other foot. Similarly, the walking
conditions for a dynamic walking robot are that the ZMP should
always be in the robot support polygon, and on foot can move iff the ZMP is over the other 
foot. For a precise description of dynamically balanced walking conditions, the reader can refer
to \cite{wieber2002}. Under these assumptions, the following result holds:

\begin{theorem}
A quasi-static walking robot is not small-space controllable. A dynamic walking robot is.
\end{theorem}

\begin{proof}

The first claim is straightforward. Let the robot be in a configuration $q$ where the two
feet are separated from a positive distance. Let us assume that the CoM is at a horizontal
distance $L>0$ from the left foot (if the CoM is over the left foot, we can consider similarly 
the right foot). For any $\epsilon < L$, any valid trajectory starting from $q$, included in
the ball of center $q$ and radius $\epsilon$, is such that the CoM is never over the left foot.
Given the quasi-static walk conditions, the right foot of the robot is fixed along 
the trajectory. Thus, the set of accessible configurations from $q$ by staying inside 
$B(q,\epsilon)$ does not form a neighborhood of $q$. This shows that the robot is 
not small-space controllable.

\bigskip

Let us now consider a dynamic walking robot. Starting from any valid static configuration, 
the CoM can move vertically without affecting balance, so there is no need to 
consider this degree of freedom in the following. If the CoM is not over the edge of the support
polygon, it is possible to move it in a quasi-static way inside a neighborhood of its current position that projects itself over the support polygon. 
It is thus sufficient and necessary to prove that for any $\epsilon >0$, it is possible to move
the feet while keeping the CoM inside a neighborhood of size $\epsilon$. Let such $\epsilon >0$
be arbitrarily fixed.


The model of a walking robot with a punctual
mass at a fixed height is known in the literature as the cart-table model \cite{kajita2003biped}.
The equations  giving  the   ZMP  horizontal  coordinates  $(p_x,p_y)$  as
functions  of CoM  horizontal coordinates $(x,y)$  in the  cart-table  model were
presented in \cite{kajita2003biped}:
\begin{equation}
\label{eq:walk-zmp}
\left(
\begin{array}{c}
p_x\\ p_y
\end{array}
\right) = \displaystyle \left(
\begin{array}{c}
x - \frac{z_c}{g} \ddot{x}\\ y - \frac{z_c}{g} \ddot{y}
\end{array}
\right)
\end{equation}
where $z_c$ is  the constant height of the CoM and  $g$ is the gravity
constant.    In    the    following    we    will    note    $\omega_0
=\sqrt{\frac{g}{z_c}}$.

Without loss of generality, let us assume that the robot is in a configuration
in which the CoM is at the horizontal position $(0,0)$, the center of the feet are 
aligned with the $y$-axis and the horizontal distance between the CoM and either of the centers
of the feet is $L$. To achieve dynamically balanced walking, we aim at making
$p_y(t)$ oscillate  between $-L$ and $L$. To move the ZMP  under a
given foot, only  the $y$ coordinate of the CoM  is of interest. Thus,
we will keep the $x$ coordinates  of the CoM and ZMP constant equal to
$0$. We have made the hypothesis that the feet were of positive surface,
let $l>0$ be such that the length of the section of a foot along the 
$y$-axis is greater than $l$.

The idea of this proof is to use the form of Eq. (\ref{eq:walk-zmp}) to
apply a  scaling factor between  the amplitude of the  oscillations of
the CoM and of the ZMP. For $\omega >0$, if the CoM follows a trajectory given
by  $y(t) = \epsilon \sin(\omega t)$,  Eq. (\ref{eq:walk-zmp}) gives:
\[
p_y(t) =
(1+\left(\frac{\omega}{\omega_0}\right)^2)\epsilon\sin(\omega t)
\]

The
amplitude  of  the oscillations  of  $y$  is  multiplied by  a  factor
$(1+\left(\frac{\omega}{\omega_0}\right)^2)$.  If we choose  $\omega =
\omega_0 \sqrt{\frac{L}{\epsilon} -1}$,  $p_y$ oscillates between $-L$
and    $L$.   At    time   $t_l^{(n)}    =    n\frac{2\pi}{\omega}   +
\frac{\pi/2}{\omega}$, the  ZMP is located  at the center of  the left
foot,  the robot  can move  its right  foot and  at time  $t_r^{(n)} =
n\frac{2\pi}{\omega}  + \frac{3\pi/2}{\omega}$ the  ZMP is  located at
the center of the right foot, the robot can move its left foot.

Starting from a static configuration at time $(t=0)$, we cannot apply
directly  a  command  $y(t)  =  \epsilon \sin(\omega  t)$  because  it
generates  a discontinuity  in the  speed of  the CoM  at time $(t=0)$. To
overcome this  discontinuity, we go through a  transient state between
$(t=0)$ and  $(t=T)$ for some  $T >0$. Let  $f:[0,T] \rightarrow
[0,1]$  be an  increasing function of class $C^\infty$  such  that  $f(0)  =  0$,
$\dot{f}(0) = 0$, $f(T) =  1$, $\dot{f}(T) = 0$ and $\ddot{f}(T)
=  0$.  We can explicitly  construct  such  an $f$   with  a degree  4
spline.   We   also   request   that   for  all   $t   \in   [0,T]$,
$|2\epsilon\dot{f}(t)\frac{\omega}{\omega_0^2}|   \leq  \frac{l}{4}$
and   $|\epsilon\ddot{f}(t)/\omega_0^2|  \leq   \frac{l}{4}$.  These
inequalities  will be  used  to bound  the  trajectory of  the  ZMP. We  can
guarantee them by  choosing $T$ large enough. Let  us now consider the
following CoM motion:

\[
y(t) = \left\{
\begin{array}{ll}
f(t)\epsilon\sin(\omega t) 
& \text{if } t\in [0,T]
\\ 
\epsilon\sin(\omega t) 
& \text{if } t \geq T \end{array}
\right.
\]

One can  check that $y$  is of class $C^2$ over  $\mathbb{R}_+$, and
that $\dot{f}(0) = 0$. When $t\geq T$, the robot is in the permanent
state described above  and can successively move its feet  inside small neighborhoods.
The  last point to check
is that for $t \in  [0,T]$ $p_y(t)$ stays inside the support polygon
of the robot. The calculation of the successive derivatives of $y$ gives:

\[
\begin{array}{cl}
p_y(t) = &  f(t) \epsilon (1 + \left(\frac{\omega}{\omega_0}\right)^2)
\sin (\omega  t) \\ &  + 2\epsilon \dot{f}(t)\frac{\omega}{\omega_0^2}
\cos  (\omega t)  \\ &  +  \frac{\epsilon}{\omega_0^2}\ddot{f}(t) \sin
(\omega t)
\end{array}
\]



\begin{figure}
\centering
\input{fig-zmp-inplace.tex}

\caption{CoM motion (in plain red) along $y$ axis.  The CoM stays in the interval
  $[-\epsilon,\epsilon]$ while during  permanent state ($t \geq T$),
  the ZMP (dashed blue) oscillates between the centers of the feet, which allows
  in-place walk.}
\label{fig:zmp-inplace}
\end{figure}

For    all     $t    \in    [0,T]$,    $f(t)     \epsilon    (1    +
\frac{\omega}{\omega_0}^2)  \sin  (\omega t)$  lies  between $-L$  and
$L$. The bounds on the derivatives of $f$ guarantee that $p_y(t)$ lies
between  $-L- l/2$ and  $L+ l/2$,  which means  that the  ZMP stays
inside  the  support  polygon.  Fig.  \ref{fig:zmp-inplace}  shows  an
example  of CoM  motion  on the  $y$  axis and  the corresponding  ZMP
motion. Once in permanent walk in-place state, the robot can come back
to  a static  state by  applying a  symmetric transient  state  used to
decrease  gradually  the amplitude  of  the  oscillations  of the  CoM
without  generating a  discontinuity in  the first  derivative  of the
command.


We have thus exhibited a continuous control scheme that allows to move any of the feet
while keeping the CoM inside an arbitrarily small neighborhood, this concludes
the proof.
\end{proof}

\subsubsection{Remarks}
\paragraph{Generalization to a complete model:} More work is needed to generalize 
the previous proof to any legged robot model. First, because we use a model where
the mass is punctual, we did not have to consider the angular-momentum of the robot
around the CoM, while it accounts for dynamic balance. Moreover, when considering
an actual kinematic and dynamic model,
the positions of feet and CoM are not controlled degrees of freedom, but inputs 
for inverse kinematic tasks. Continuity and regularity results about the robot
controller -- i.e. how much the configuration changes when the input of an inverse
kinematic task changes--, would be needed to generalize the proof. We have not
proven such properties. The  proof presented above still gave the intuition for the
algorithm presented in the following.


\paragraph{Use of ZMP preview controller:} The control strategy presented in the  
previous proof may
generate very  long trajectories, because  of the transient  states at
the beginning and end of the locomotion. In the actual implementation,
we chose  to generate  CoM motions with  a ZMP preview  controller, as
presented in \cite{kajita2003biped}.  We  have observed experimentally that the
amplitude of  CoM trajectories decreases  when the frequency  of steps
increases.

\paragraph{Speed of CoM:} The theoretical result presented in this section implies
that any collision-free path can be approximated by a sequence of admissible 
and collision-free trajectories. However, the theorem depends on a control law
that will generate trajectories with unbounded velocities for the CoM, when the input
path is close to obstacles. The humanoid robot
hardware may be a limitation to such trajectories. To prevent the generated CoM 
oscillations from being too fast, one has to require that the statically stable 
path is included
inside an $\epsilon$-radius tube of the free space, where $\epsilon$ depends on the
physical capacities of the robot.




\subsection{Application: Dynamic Approximation of a Statically Stable Sliding Path}
\label{sec:ssc-application}


The  algorithm   that  animates  a  statically  stable   path  into  a
dynamically stable  walk trajectory has been inspired  by the previous
small-space controllability  proof. Given a statically  stable path $p$,
we  start  by placing  footsteps  corresponding  to  the nominal  walk
pattern  of the  robot. Given the footsteps, we  compute a ZMP trajectory, 
and a preview controller outputs  a corresponding CoM trajectory, using
the cart-table model.
The stack of tasks applied to
the robot is - in decreasing priority order:

\begin{enumerate}

\item Position and orientation of  feet,

\item Horizontal position of the CoM,

\item Height of the CoM,

\item Verticality of the waist,

\item Upper-body configuration task towards corresponding
  configuration  of $p$.

\end{enumerate}

Tasks (1)  and (2) generate a  dynamically stable motion  by using the
simplified cart-table model  and the ZMP criterion. Tasks  (3) and (4)
ensure that the  resulting motion is well described  by the cart-table
model. Task (5)  is used to approximate $p$ as  well as possible given
the walk parameters.

Because it comes at the  lowest priority, task (5) is not necessarily
fulfilled in  the resulting trajectory. Hence,  collisions may appear
when animating $p$, if the resulting trajectory diverges too much from
the initial sliding  path. If so, it is  necessary to approximate more
closely $p$  by a walk  trajectory.  To do  so, we use  the small-space
controllability  property   of  the  system  shown   in  the  previous
section. The way  we use this property is  inspired by similar results
in non-holonomic mobile robot control presented in \cite{taix-94}.

If the animated  trajectory collides with the environment,  we cut the
initial  path   $p$  into  two   sub-paths,  that  we  try   to  animate
recursively. When the  paths to animate are too  short for the robot
nominal  walk parameters, we  accelerate the  steps, and  decrease the
maximum height of  the moving foot. As shown  in previous section, the
walk trajectory  corresponding to  smaller and faster  steps converges
toward the  sliding path.  Algorithm  \ref{alg:walk} shows pseudo-code
that takes  a sliding path $p$  as input and  returns a collision-free
walk trajectory.

\begin{algorithm}[h]
\caption{FindDynamicTrajectory(Path $p$)}
\label{alg:walk}
\begin{algorithmic}
\STATE $Footprints \leftarrow \text{ComputeFootprints}(p)$

\STATE $StackOfTasks$.initialize()

\STATE $StackOfTasks$.addFootprintTask($Footprints$)

\STATE $StackOfTasks$.addWaistTask()

\STATE $StackOfTasks$.addConfigurationTask($p$)

\STATE $DynamicTrajectory \leftarrow \text{Animate}(StackOfTasks)$

\IF{(CheckForCollisions($DynamicTrajectory$) = Colliding)}

\STATE $(p_1,p_2) \leftarrow \text{CutInHalf}(p)$

\STATE $DT_1 \leftarrow \text{FindDynamicTrajectory}(p_1)$

\STATE $DT_2 \leftarrow \text{FindDynamicTrajectory}(p_2)$

\RETURN $\text{Concatenate}(DT_1,DT_2)$

\ELSE

\RETURN $DynamicTrajectory$

\ENDIF
\end{algorithmic}
\end{algorithm}





\section{Experimental Results}

\label{sec:exp}

The motion planning algorithms presented in this paper have been implemented
using KineoWorks\texttrademark \cite{laumond2006kcs}. The planning times have been measured
on an Intel Core~2~Duo 2.13~GHz PC with 2~GB of RAM. Evaluation of the
randomized algorithm has been conducted by executing 50 trials on each
of the first two problems. We present the average results of these trials.



\subsection{Passing between two chairs}

The environment shown in Fig. \ref{fig:couv} and \ref{fig:sliding} was
presented in \cite{el2011path}. The  authors solved it by using a bounding
box method, leading the robot to walk sideways between the two chairs.
Our method generated a locomotion  trajectory in which the robot walks
forward, which could be required if the robot has to use vision during
locomotion for  example. The first planning stage  required 29.6~s
on  average.   The  animation  of   the  sliding  path   presented  in
Fig.   \ref{fig:sliding}    used   66.5~s  of  computation   time.


\begin{figure}[h!]
\centering
\includegraphics[width=0.7\linewidth]{pics/chairs/waist-trajectory.png}

\caption{Horizontal trajectory of the robot CoM during
  locomotion. When the robot is close to obstacles, the amplitude of
  the oscillations decreases.}
\label{fig:chairs-waist}
\end{figure}



Fig.  \ref{fig:chairs-waist} shows  the horizontal  trajectory  of the
robot CoM  during  locomotion. The amplitude of the oscillations  decreases when passing
between the  chairs.  This motion has  been validated on  a real HRP-2
platform. Extension 2 shows a video of the experiment.


\subsection{Walking among floating obstacles}

\begin{figure}[h!]

\centering

\includegraphics[width=0.24\linewidth]{pics/objects-cloud/perspective-1.png}
\includegraphics[width=0.24\linewidth]{pics/objects-cloud/perspective-2.png}
\includegraphics[width=0.24\linewidth]{pics/objects-cloud/perspective-3.png}
\includegraphics[width=0.24\linewidth]{pics/objects-cloud/perspective-4.png}
\\ 
\vskip 0.08cm
\includegraphics[width=0.24\linewidth]{pics/objects-cloud/perspective-5.png}
\includegraphics[width=0.24\linewidth]{pics/objects-cloud/perspective-6.png}
\includegraphics[width=0.24\linewidth]{pics/objects-cloud/perspective-7.png}
\includegraphics[width=0.24\linewidth]{pics/objects-cloud/perspective-8.png}

\caption{Solution path for a cluttered environment, the robot walks
  among floating obstacles.}
\label{fig:cluttered}
\end{figure}

In the environment shown in Fig. \ref{fig:cluttered}, the robot
has to find a way among floating obstacles. In this
environment neither bounding box nor footstep planning strategies
could find a collision-free walk trajectory.
The first planning stage required
184.3~s on average, and the animation of the trajectory presented in 
Fig.~\ref{fig:cluttered} used 339.5~s of computation time. Fig.~\ref{fig:cluttered-waist} 
shows the robot CoM trajectory during locomotion.

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.7\linewidth]{pics/objects-cloud/waist-trajectory.png}

  \caption{Horizontal trajectory of the robot CoM during
    locomotion.}
  \label{fig:cluttered-waist} 
\end{figure}


\subsection{'Put the ball on a shelf'}

In the problem shown in Fig. \ref{fig:shelf} the robot has to put a ball on a
shelf, in a constrained apartment environment. The final configuration is defined 
implicitly as a desired hand position. We generated automatically goal configurations 
solving the task, as described in Section~\ref{sec:wb} . Then, we 
applied our planner to generate a whole-body walk motion that solved the hand reaching
task. 

The solution sliding path is constrained between the table on the right and the lamp
on the left. This passage is too narrow for the robot nominal walk parameters. 
When executing the walk motion resulting from our algorithm, the robot left hand
is only a few centimeters away from the lamp.

Fig.~\ref{fig:shelf} shows the resulting walk motion and Fig.~\ref{fig:shelf-waist} 
shows the robot CoM trajectory during locomotion. Extension 3 presents a 
comprehensive video of this problem, including the motion execution on
the real robot HRP-2.



\begin{figure}[h]
\centering
\includegraphics[width=0.24\linewidth]{pics/shelves/trajectory-1.png}
\includegraphics[width=0.24\linewidth]{pics/shelves/trajectory-2.png}
\includegraphics[width=0.24\linewidth]{pics/shelves/trajectory-3.png}
\includegraphics[width=0.24\linewidth]{pics/shelves/trajectory-4.png}
\\ 
\vskip 0.1cm
\includegraphics[width=0.24\linewidth]{pics/shelves/trajectory-5.png}
\includegraphics[width=0.24\linewidth]{pics/shelves/trajectory-6.png}
\includegraphics[width=0.24\linewidth]{pics/shelves/trajectory-7.png}
\includegraphics[width=0.24\linewidth]{pics/shelves/trajectory-8.png}

\caption{Solution path for a hand reaching problem in an
  appartment. The goal is implicitly defined as an inverse kinematics
  task.} 
\label{fig:shelf}
\end{figure}




\begin{figure}[h]
\centering

\includegraphics[width=0.5\linewidth]{pics/shelves/waist-trajectory.png}


\caption{Horizontal trajectory of the robot CoM during
    locomotion.}
\label{fig:shelf-waist}
\end{figure}



\section{Limits and Discussions}
\label{sec:limits}

This section lists several limitations of the current methods, and discusses
potential future work to overcome them.


\subsection{Stepping over obstacles}

Because of the kinematic constraints we apply at the planning stage, we are not
able yet to plan motions where the robot steps over obstacles, while this is an 
important feature of humanoid robots. Nevertheless, because we compute collision queries on
an exact model of the robot, our method is able to generate paths where obstacles
pass between the feet of the robot.
In future work, we plan to develop mixed
methods, where collision avoidance at the leg level can be solved by footstep
planning techniques, while whole-body collision-avoidance can be solved by the
algorithm presented in this paper.

\subsection{Environment representation}

The presented experiment setup assumes perfect knowledge of the environment. This can
be guaranteed during experiments by using calibrated objects and motion capture systems.
This allows us to focus on complex motion planning problems. The perception problem,
interesting as it is, is completely decoupled from the planning problem in our
presentation. 


\subsection{Trajectory following}

The presented setup also assumes perfect execution of the plan. It can be 
critical here, since
non-nominal stepping may cause to drift away from the planned trajectory. Future 
experiments will  include trajectory following during plan execution.

\section{Conclusion}

In this paper, we have presented a simple algorithm for constrained motion planning
and used it within a novel, well-grounded strategy for humanoid whole-body
manipulation planning including locomotion. The locomotion algorithm is based on a formal
small-space controllability property of humanoid robots. An important point is that
this strategy only holds for dynamic walking robots, and not for quasi-static walking ones.
We have used our motion planner on different challenging examples, and validated the
generated motions on a real platform. We have discussed the limits and potential extensions
of our method, and we plan to address them in future work.


\bibliographystyle{agsm}   


\bibliography{bibli}



\end{document}
